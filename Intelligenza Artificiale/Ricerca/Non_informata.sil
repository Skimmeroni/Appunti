\begin{sile}

	Un algoritmo di ricerca \strong{non informato} non possiede informazioni
	in merito a "quanto vicino" sia uno stato rispetto agli obiettivi.

	\subsection{Backtracking search}

		\strong{Backtracking search} é un algoritmo di ricerca dove
		la strategia usata consiste essenzialmente nell'espandere
		sempre il nodo piú profondo.

		Nello specifico, Backtracking search espande prima la
		radice, poi sceglie il primo nodo cosí generato e lo
		espande, dopodiché sceglie il primo nodo da questo
		generato e lo espande, ecc\ddd Se viene raggiunto un
		nodo il cui relativo stato é uno stato obiettivo,
		l'algoritmo termina restituendo il percorso costruito.
		Se viene invece raggiunto un nodo il cui stato non é
		uno stato obiettivo ma che non é piú possibile espandere,
		l'algoritmo opera un \strong{backtracking}, ovvero "ritorna"
		al primo nodo lungo il percorso che non é stato ancora
		interamente espanso.

		\begin{verbatim}
			procedure BACKTRACKING-SEARCH(s, path)
			    if (IS-END(s)) then
			        update bestPath
			    foreach a in ACTIONS(s) do
			        Extend path with SUCCESSOR(s, a)
			        BACKTRACKING-SEARCH(SUCCESSOR(s, a), path)
			    return bestPath
		\end{verbatim}

		Se lo spazio degli stati é finito, Backtracking search
		é completo fintanto che non esistono cicli; sebbene
		possa esplorare gli stessi stati piú volte negli stessi
		percorsi, prima o poi tutti gli stati vengono raggiunti.
		Se sono presenti dei cicli, l'algoritmo potrebbe rimanere
		bloccato in un loop infiniti. Se lo spazio degli stati é
		infinito, l'algoritmo non é né sistematico né completo,
		perché l'algoritmo potrebbe rimanere bloccato nell'espandere
		lo stesso percorso indefinitamente, anche se non sono presenti
		cicli.

		Un possibile modo per garantire la completezza di Backtracking
		search consiste nel fissare una profonditá massima \math{D},
		oltre la quale l'algoritmo compie backtracking a prescindere
		dal nodo in esame. Tuttavia, cosí facendo, l'algoritmo non é
		piú in grado di garantire la correttezza, perché tutte le
		soluzioni che si trovano ad una profonditá maggiore di \math{D}
		sono perdute. Un approccio di questo tipo é preferibile solamente
		se la natura del problema permette di conoscere in anticipo che
		non puó esistere una soluzione piú in profonditá di \math{D}.

		\begin{verbatim}
			procedure BOUNDED-BACKTRACKING-SEARCH(s, path, D)
			    if (|path| > D) then
			        return NULL
			    if (IS-END(s)) then
			        update bestPath
			    foreach a in ACTIONS(s) do
			        Extend path with SUCCESSOR(s, a)
			        BOUNDED-BACKTRACKING-SEARCH(SUCCESSOR(s, a), path, D)
			    return bestPath
		\end{verbatim}

		Lo spazio occupato in termini di memoria é \math{O(b D)},
		che é un limite contenuto. In termini di tempo di esecuzione,
		il limite é invece \math{O(b^{D})}, che rende l'algoritmo
		molto inefficiente in termini di tempo.

	\subsection{Depth-First search}

		Una variante di Backtracking search é \strong{Depth-First search},
		che opera con la stessa strategia ma si interrompe immediatamente
		appena viene trovata una soluzione.

		\begin{verbatim}
			procedure DEPTH-FIRST-SEARCH(s, path, D)
			    if (|path| > D) then
			        return NULL
			    if (IS-END(s)) then
			        return path
			    foreach a in ACTIONS(s) do
			        Extend path with SUCCESSOR(s, a)
			        DEPTH-FIRST-SEARCH(SUCCESSOR(s, a), path, D)
		\end{verbatim}

		La soluzione restituita da Depth-First search é la prima che viene
		trovata, ma non vi é alcuna garanzia che questa sia una soluzione
		ottimale. Infatti, potrebbe esserci una soluzione migliore di quella
		trovata lungo i nodi lasciati inesplorati, ma questi non verranno mai
		raggiunti. Fintanto che lo spazio degli stati é finito e fintanto che
		le soluzioni si trovano a meno profonditá di \math{D}, Depth-First
		search é comunque completo, perché una soluzione (per quanto non
		necessariamente ottimale) verrá sempre trovata.

		Depth-First search ha peró il vantaggio di dover tenere traccia,
		in genere in una coda FIFO, solamente dei nodi in esame e dei vari
		punti di scelta, non di tutti i percorsi finora trovati. Inoltre,
		sebbene il tempo di esecuzione teorico nel caso peggiore sia comunque
		\math{O(T^{D})}, nella pratica questo tende ad essere molto inferiore,
		perché una soluzione viene trovata molto prima di esplorare l'albero
		per intero.

	\subsection{Breadth-First search}

		Quando tutte le azioni hanno il medesimo costo, un algoritmo di ricerca
		non informato che conviene utilizzare é \strong{Breadth-First search}.
		In questo algoritmo, il nodo radice dell'albero di ricerca viene espanso,
		dopodiché ciascuno dei nodi che questo genera viene espanso, dopodiché
		ciascuno dei nodi che questi a loro volta generano viene espanso, ecc\ddd
		fino ad esaurire tutti i nodi. Questa strategia rispetta la proprietá di
		sistematicitá, e pertanto garantisce che l'algoritmo sia completo anche 
		se lo spazio degli stati é infinito.

		L'algoritmo \tt{BREADTH-FIRST-SEARCH} puó essere implementato, in
		prima analisi, come una versione di \tt{BEST-FIRST-SEARCH} in cui
		la funzione di valutazione \math{f(n)} é la profonditá di \math{n},
		ovvero il numero di azioni che é stato necessario per arrivare dalla
		radice a \math{n}. Come struttura dati atta a contenere i nodi della
		frontiera é bene scegliere una coda FIFO. Questo perché i nuovi nodi
		che vengono aggiunti, che si trovano necessariamente dopo i nodi che
		li hanno generati, vengono posti in fondo alla coda, mentre i nodi
		giá nella coda, che sono stati quindi aggiunti prima, vengono espansi
		prima.

		É possibile ottimizzare ulteriormente l'algoritmo osservando
		come non sia necessario tenere traccia dei percorsi precedentemente
		usati per raggiungere un certo nodo, perché per come l'algoritmo é
		strutturato, una volta che un nodo viene raggiunto non é possibile
		trovare un percorso migliore per raggiungerlo. Pertanto, non é
		necessario implementare \tt{reached} come una hash table, ma é 
		sufficiente che sia un insieme non ordinato. Inoltre, per lo stesso
		motivo, é possibile valutare se un nodo é un nodo obiettivo prima di
		controllare se tale nodo é giá stato raggiunto.

		\begin{verbatim}
			function BREADTH-FIRST-SEARCH(problem)
				node <= /a new empty node/
				node.state <= initial-state
				frontier <= /a FIFO queue, with/ node /as an element/
				reached <= \{initial-state\}
				while not IS-EMPTY(frontier) do
					node <= POP(frontier)
					ex <= EXPAND(node)
					foreach child in ex do
						s <= child.state
						if (IS-GOAL(s) = True) then
							return child
						if (s not in reached) then
							reached <= reached \unichar{U+222A} \{s\}
							ADD(frontier, child)
				return error
		\end{verbatim}

		Breadth-first search, quando trova una soluzione, tale soluzione sará
		necessariamente trovata con il minor numero di passi possibili. Questo
		perché quando viene generato un nodo alla profonditá \math{d}, tutti i
		nodi a profonditá \math{d - 1}, \math{d - 2}, ecc\ddd sono giá stati 
		generati (ed espansi). Pertanto, se uno di questi nodi avesse contenuto
		uno stato obiettivo, sarebbe giá stato trovato. Pertanto, se il costo
		di tutte le azioni del problema é lo stesso, Breadth-first search é
		necessariamente l'algoritmo piú efficiente possibile dal punto di vista
		del costo. Inoltre, é un algorimo completo, perché prima o poi tutti i
		nodi verranno raggiunti.

		Per quanto riguarda la complessitá di breadth-first search, si osservi
		come a partire dal nodo iniziale vengano allora generati al piú \math{b}
		nodi, ed a sua volta a partire da ciascuno di questi vengono generati al
		piú \math{b} nodi, ecc\ddd Questo significa che ad una certa profonditá
		\math{d}, vengono generati al piú \math{b^{d}} nodi. L'algoritmo prevede
		che tutti questi nodi debbano potenzialmente venire generati ed esplorati,
		a meno di trovare una soluzione prima di averli esauriti, pertanto
		la complessitá in termini sia di tempo che di spazio della ricerca
		breadth-first é \math{O(b^{d})}. Questo significa che, per quanto
		breadth-first search sia completo, é molto inefficiente, a meno di
		operare su istanze molto piccole.

	%\subsection{Uniformed-Cost search}

\end{sile}
