\begin{sile}

	Prende il nome di \strong{algoritmo di ricerca} un
	algoritmo che, avendo in input un problema di ricerca
	con una data istanza, restituisce in output una soluzione
	a tale problema se (almeno) una soluzione esiste, oppure
	un errore se non esiste alcuna soluzione.

	In termini molto generali, é possibile descrivere un algoritmo
	di ricerca in questo modo. Viene innanzitutto creato l'insieme
	\tt{PartialSolutionSet}, che inizialmente contiene il solo stato
	iniziale. Fintanto che l'insieme \tt{PartialSolutionSet} non é
	vuoto, l'algoritmo cerca di trovare una soluzione; se l'insieme
	si svuota, allora una soluzione non esiste.

	Il corpo del ciclo principale inizia estraendo uno dei
	percorsi di \tt{PartialSolutionSet} ed analizzando l'ultimo
	stato di tale percorso. Per ciascuna azione applicabile in
	tale stato, viene creato un insieme \tt{Successors} che
	contiene tutti gli stati raggiungibili a partire da tale
	stato compiendo tali azioni. Per ciascuno degli stati cosí
	raggiunti, si costruisce una \tt{potentialSolution} accodando
	tale stato al percorso corrente e si valuta se lo stato in
	questione é uno stato obiettivo: se lo é, allora
	\tt{potentialSolution} é effettivamente una soluzione e
	l'algoritmo la restituisce, altrimenti \tt{potentialSolution}
	viene aggiunta a \tt{PartialSolutionSet}.

	\begin{verbatim}
		procedure GENERIC-SEARCH(initialState, choosingStrategy, insertingStrategy)
		    PartialSolutionSet = [initialState]
		    while (PartialSolutionSet \unichar{U+2260} []) do
		        path \unichar{U+2190} CHOOSE-PATH(PartialSolutionSet, choosingStrategy)
		        lastState \unichar{U+2190} path[-1]
		        Successors \unichar{U+2190} []
		        foreach action in ACTIONS(lastState) do
		            Successors \unichar{U+2190} Successors \unichar{U+222A} \{RESULT(lastState, action)\}
		        foreach state in Successors do
		            potentialSolution \unichar{U+2190} path + state
		            if (state.type = "goal") then
		                return potentialSolution
		            else
		                PartialSolutionSet \unichar{U+2190} INSERT-PATH(PartialSolutionSet, potentialSolution, insertingStrategy)
		    return "No solution found"
	\end{verbatim}

	La funzione \tt{CHOOSE-PATH} determina quale dei percorsi finora
	costruiti debba essere quella da analizzare nell'iterazione corrente,
	mentre la funzione \tt{INSERT-PATH} inserisce il nuovo percorso appena
	costruito in una determinata posizione di \tt{PartialSolutionSet}.
	Entrambe dipendono da una certa \strong{strategia}, ovvero da un set
	di regole usate per determinare la scelta. L'adottare una strategia
	piuttosto che un'altra influisce notevolmente sulle prestazioni
	dell'algoritmo, perché prima un percorso che si rivelerá poi
	essere una soluzione viene analizzato e prima l'algoritmo termina
	(naturalmente, l'algoritmo non puó sapere in anticipo se il percorso
	in analisi é oppure non é una soluzione, altrimenti il problema non
	si porrebbe proprio).

	L'algoritmo ha due cicli for innestati, pertanto il tempo di
	esecuzione é approssimativamente quadratico nel numero degli
	stati. Ogni volta che all'algoritmo viene passato in input
	uno stato, questo ricalcola (se esiste) una soluzione che
	abbia quello stato come stato iniziale. Un algoritmo di
	questo tipo rientra nella categoria degli agenti guidati da
	modello e basati su obiettivi.

	Ci si chiede se é possibile costruire un algoritmo che rientri
	nella categoria degli agenti semplici. Tecnicamente, sarebbe
	possibile utilizzare l'algoritmo per costruire una sorta di
	lookup table, dove a ciascuno stato iniziale é associata la
	relativa soluzione; in questo modo, sarebbe necessario richiamare
	l'algoritmo una sola volta per ciascuno stato, dopodiché la soluzione
	per uno stato giá passato in input verrebbe restituita immediatamente.
	Difficilmente questo approccio potrebbe funzionare, perché un problema
	reale ha un numero di stati troppo grande; una singola esecuzione
	dell'algoritmo ripetuta per ogni possibile stato iniziale sarebbe
	comunque insostenibile. Inoltre, l'algoritmo presuppone che sia
	possibile ottenere tutte le informazioni dall'ambiente, ma questo
	é vero solamente se l'ambiente é accessibile.

	\begin{example}
		Nella prima versione del problema di Pacman dell'esempio
		precedente, un approccio di questo tipo é effettivamente
		possibile. Essendo il numero totale di stati 16, a ciascuno
		di questi é possibile associare uno dei possibili percorsi
		ottimali in una tabella di questo tipo:

		\begin{center}
			\begin[cols = 15%fw 70%fw]{ptable}
				\begin{row}
					\cell{\strong{Stato iniziale}} \cell{\strong{Soluzione}}
				\end{row}
				\begin{row}
					\cell{\tt{(1, 1)}}
					\begin{cell}
						\begin{tt}
							(1, 1) \unichar{U+2192} (2, 1) \unichar{U+2192}
							(2, 2) \unichar{U+2192} (2, 3) \unichar{U+2192}
							(3, 3) \unichar{U+2192} (3, 4) \unichar{U+2192}
							(4, 4) 
						\end{tt}
					\end{cell}
				\end{row}
				\begin{row}
					\cell{\tt{(2, 1)}}
					\begin{cell}
						\begin{tt}
							(2, 1) \unichar{U+2192} (2, 2) \unichar{U+2192}
							(2, 3) \unichar{U+2192} (3, 3) \unichar{U+2192}
							(3, 4) \unichar{U+2192} (4, 4) 
						\end{tt}
					\end{cell}
				\end{row}
				\begin{row}
					\cell{\tt{(3, 1)}}
					\begin{cell}
						\begin{tt}
							(3, 1) \unichar{U+2192} (3, 2) \unichar{U+2192}
							(3, 3) \unichar{U+2192} (3, 4) \unichar{U+2192}
							(4, 4) 
						\end{tt}
					\end{cell}
				\end{row}
				\begin{row}
					\cell{\tt{\ddd}}
					\cell{\tt{\ddd}}
				\end{row}
				\begin{row}
					\cell{\tt{(3, 4)}}
					\begin{cell}
						\begin{tt}
							(3, 4) \unichar{U+2192} (4, 4) 
						\end{tt}
					\end{cell}
				\end{row}
				\begin{row}
					\cell{\tt{(4, 4)}}
					\begin{cell}
						\begin{tt}
							(4, 4) 
						\end{tt}
					\end{cell}
				\end{row}
			\end{ptable}
		\end{center}
		\par\smallskip

		Applicare un approccio simile alla seconda versione del problema
		diviene invece del tutto irrealistico, dato che il numero totale
		di stati é troppo grande.
	\end{example}

	I percorsi generati dall'algoritmo possono essere rappresentati
	attraverso una struttura ad albero, detta \strong{albero di
	ricerca}. Ciascun nodo di tale albero corrisponde ad uno degli
	stati nello spazio degli stati, mentre gli archi corrispondono
	alle azioni che costituiscono le transizioni. La radice dell'albero
	corrisponde allo stato iniziale del problema. Una soluzione non é
	altro che un percorso nell'albero che va dal nodo iniziale ad un
	nodo foglia che ha associato uno stato obiettivo.

	É possibile tradurre l'algoritmo di ricerca generico in termini di
	alberi. L'albero, \tt{Tree}, inizialmente contiene il solo nodo
	radice, cosí come l'insieme \tt{Leaves}, detto \strong{frontiera},
	che riporta tutti i nodi foglia. Fintanto che l'insieme \tt{Leaves}
	non é vuoto, l'algoritmo cerca di trovare una soluzione; se l'insieme
	si svuota, allora una soluzione non esiste. Ciascun nodo puó essere
	pensato come una struttura a due campi: un campo \tt{parent} che
	indica il rispettivo nodo genitore ed un campo \tt{state} che
	indica lo stato a cui il nodo é associato. \tt{Leaves} é, in
	genere, una coda di prioritá, mentre \tt{Tree} puó essere una
	qualsiasi rappresentazione usata per gli alberi.

	Il corpo del ciclo principale inizia estraendo \tt{nodeToExpand},
	uno dei nodi in \tt{Leaves}, attraverso una determinata strategia;
	il nodo viene rimosso da \tt{Leaves}. Viene poi analizzato lo stato
	associato a tale nodo, ovveor \tt{nodeToExpand.state}: se questo é
	uno stato obiettivo, allora si ricostruisce una soluzione salendo di
	nodo in nodo attraverso il campo \tt{parent} fino a trovare la radice,
	che é identificabile univocamente essendo l'unico nodo ad avere
	\tt{NULL} come valore per questo campo.

	Se invece \tt{nodeToExpand.state} non é uno stato obiettivo, viene
	applicata a \tt{nodeToExpand} l'operazione di \strong{espansione}.
	Questa consiste nel costruire tanti nodi \tt{newNode} per ciascuna
	azione applicabile in \tt{nodeToExpand.state}, ciascuno avente tale
	azione come campo \tt{action} e avente \tt{nodeToExpand} come campo
	\tt{parent}. Tale nodo viene poi aggiunto a \tt{Leaves}, mentre a
	\tt{Tree} viene aggiunta una tupla che ha \tt{nodeToExpand} e
	\tt{newNode} come elementi, che rappresenta la transizione compiuta
	dagli stati riferiti ai due nodi.

	\begin{verbatim}
		procedure GENERIC-TREE-SEARCH(initialState, strategy)
		    root.parent \unichar{U+2190} NULL
		    root.state \unichar{U+2190} initialState
		    Leaves \unichar{U+2190} [root]
		    Tree \unichar{U+2190} [root]
			while (Leaves \unichar{U+2260} []) do
			    nodeToExpand \unichar{U+2190} EXTRACT-LEAF(Leaves, strategy)
			    if (nodeToExpand.state.type = "goal") then
				    thisNode = nodeToExpand
				    Solution = []
				    do
				        Solution \unichar{U+2190} Solution + thisNode
					    thisNode \unichar{U+2190} thisNode.parent
				    while (thisNode.parent \unichar{U+2260} NULL)
					return Solution
			    else
			        foreach action in ACTIONS(nodeToExpand.state) do
					    newLeaf.state \unichar{U+2190} RESULT(nodeToExpand.state, action)
					    newLeaf.parent \unichar{U+2190} nodeToExpand
					    Leaves \unichar{U+2190} Leaves \unichar{U+222A} \{newLeaf\}
					    Tree \unichar{U+2190} Tree \unichar{U+222A} (nodeToExpand, newLeaf)
			return "No solution found"
	\end{verbatim}

	\tt{GENERIC-SEARCH} e \tt{GENERIC-TREE-SEARCH} sono di fatto
	equivalenti. Il vantaggio di \tt{GENERIC-TREE-SEARCH} é che
	utilizza una rappresentazione "standardizzata", quella ad 
	albero, che permette di utilizzare strutture dati note per
	tenere traccia delle computazioni (\tt{GENERIC-SEARCH} non
	specifica che strutture dati utilizzare). Infatti, é presente
	un solo parametro \tt{strategy} anziché due, perché non c'é
	ambiguitá né nello scegliere in che posizione inserire la tupla
	nell'albero in costruzione, né nello scegliere in che posizione
	inserire il nodo nella frontiera (INSERT-PATH richiedeva di
	esplicitare una strategia).

	\tt{GENERIC-TREE-SEARCH} introduce peró uno svantaggio, ovvero
	che non vi é garanzia che l'algoritmo termini. Infatti, é sufficiente
	che esista sia una transizione da uno stato A ad uno stato B che una
	transizione da B ad A perché l'algoritmo entri in un loop infinito.
	La mappatura fra nodi dell'albero di ricerca e stati dello spazio
	degli stati non é uno-ad-uno, perché uno stato puó figurare diverse
	volte come nodo dell'albero.

	Si noti inoltre come, anche se l'algoritmo dovesse trovare una
	soluzione, non c'é garanzia che questa sia la migliore, ovvero
	quella costituita dal minimo numero di nodi. Se il numero di 
	soluzioni é finito, un possibile approccio consisterebbe nel 
	modificare \tt{GENERIC-TREE-SEARCH} per farlo terminare non 
	nel momento in cui viene trovata una soluzione, ma quando sono
	state trovate tutte e sono state comparate.

	\begin{verbatim}
		procedure BACKTRACKING-SEARCH(s, path)
		    if (IS-END(s)) then
		        update bestPath
		    foreach a in ACTIONS(s) do
		        Extend path with SUCCESSOR(s, a)
		        BACKTRACKING-SEARCH(SUCCESSOR(s, a), path)
		    return bestPath
	\end{verbatim}

	Se peró si verifica anche un solo loop, dato che tutti i
	possibili percorsi devono per forza essere esplorati, prima
	o poi tale loop verrá raggiunto. Questa criticitá potrebbe
	essere aggirata introducendo una profonditá massima \math{D},
	oltre la quale la computazione viene interrotta immediatamente.
	Questo garantisce di non poter incappare un loop infinito, ma
	non garantisce piú che una soluzione venga effettivamente trovata.
	Questo perché se le soluzioni si trovano ad una profonditá maggiore
	di \math{D} queste non verranno mai raggiunte.

	\begin{verbatim}
		procedure BACKTRACKING-SEARCH(s, path, D)
		    if (|path| > D) then
		        return NULL
		    if (IS-END(s)) then
		        update bestPath
		    foreach a in ACTIONS(s) do
		        Extend path with SUCCESSOR(s, a)
		        BACKTRACKING-SEARCH(SUCCESSOR(s, a), path, D)
		    return bestPath
	\end{verbatim}

	Un algoritmo di ricerca si dice \strong{completo} se garantisce,
	per qualsiasi istanza del problema di ricerca, di trovare una
	soluzione, sia che questa sia uno stato raggiunto (soluzione
	trovata) sia che questa sia un messaggio di errore (soluzione
	non trovata). Se invece esiste almeno una istanza del problema
	per il quale questo non é in grado di fornire una risposta e si
	blocca indefinitamente, allora si dice che tale algoritmo é
	\strong{incompleto}.

	Un algoritmo di ricerca che opera su uno spazio degli stati finito
	é certamente completo, perché prima o poi tutti gli stati verrano
	raggiunti e, se nessuno di questi é uno stato obiettivo, restituisce
	un messaggio d'errore. Per poter essere completo, un algoritmo di
	ricerca che opera su uno spazio degli stati infinito deve essere
	\strong{sistematico}, ovvero esplorare lo spazio in modo da poter
	raggiungere tutti gli stati che possono essere raggiunti a partire
	dallo stato iniziale.

	In genere, le prestazioni di un algoritmo che opera su un
	grafo sono espresse in termini della cardinalitá del suo
	insieme di archi e della cardinalitá del suo insieme di
	vertici. Per misurare le prestazioni di un algoritmo di
	ricerca si preferisce invece misurare le prestazioni in
	termini di: \math{D}, la \strong{profonditá}, ovvero
	il numero di azioni in una soluzione ottimale; \math{m},
	il massimo numero di azioni che possono comparire in un
	percorso; e \math{b}, il \strong{fattore di branching},
	ovvero il massimo numero di successori di un nodo che é
	necessario considerare.

	Nel caso specifico di \tt{BACKTRACKING-SEARCH}, lo spazio
	occupato in termini di memoria é \math{O(b D)}, che é
	un limite contenuto. In termini di tempo di esecuzione,
	il limite é invece \math{O(b^{D})}, che rende l'algoritmo
	molto inefficiente in termini di tempo.

\end{sile}
