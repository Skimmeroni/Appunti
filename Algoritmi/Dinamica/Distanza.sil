\begin{sile}

	\subsection{Definizione del problema}

		La formulazione della distanza fra due sequenze più semplice
		e più utilizzata è la cosiddetta \strong{distanza di modifica}
		(\strong{edit distance}) \footnote{Anche chiamata \strong{distanza
		di Levenshtein}.}. Date due sequenze \math{X} e \math{Y}, la
		distanza di modifica fra le due è data dal numero di operazioni
		atomiche sui singoli caratteri necessario a trasformare \math{X}
		in \math{Y}, "scansionandola" da sinistra verso destra. Le operazioni
		ammesse sono tre:

		\begin{enumerate}
			\begin{item}
				\strong{Insert(a)}, ovvero \em{inserire} il carattere \math{a}
				nella posizione corrente nella sequenza \math{X};
			\end{item}
			\begin{item}
				\strong{Delete(a)}, ovvero \em{rimuovere} il carattere \math{a}
				nella posizione corrente nella sequenza \math{X};
			\end{item}
			\begin{item}
				\strong{Replace(a, b)}, ovvero \em{sostituire} il carattere \math{a}
				con il carattere \math{b} nella posizione corrente nella sequenza
				\math{X};
			\end{item}
		\end{enumerate}

		\bigskip

		Siano le tre operazioni sopra citate abbreviate rispettivamente
		con \math{I}, \math{D} e \math{R}. Una concatenazione di queste
		operazioni può essere espressa come una sequenza sull'alfabeto
		\math{\{I, D, R\}}. Ovvero, una sequenza del tipo \math{op_{1}
		op_{2} op_{3} \unicodeellipsis op_{n}}, costruita usando i tre
		caratteri dell'alfabeto sopra descritto, è una sequenza dove
		ciascun carattere \math{op_{i}} indica l'operazione applicata
		all'\math{i}-esimo carattere della prima stringa per poterla
		trasformare nella seconda.

		Una sequenza che esprime la sequenza di operazioni necessarie
		a trasformare una sequenza in un'altra viene chiamata
		\strong{trascrizione} delle due sequenze. In particolare, una
		trascrizione che é costituita dal minimo numero di caratteri
		possibili é detta trascrizione ottimale. Il \strong{Problema
		della distanza di modifica} richiede di trovare, prese due
		sequenze, una qualsiasi trascrizione ottimale che permette
		di trasformare la prima nella seconda.

		Anziché affrontare il problema direttamente, si preferisce prima
		trovare la lunghezza di una possibile trascrizione ottimale di
		due sequenze e poi, sulla base di questa informazione, ricostruire
		la trascrizione ottimale "a ritroso". Pertanto, il problema
		effettivamente in esame sará il problema della lunghezza della
		trascrizione ottimale.

		Il problema puó essere risolto mediante programmazione dinamica.
		Date due sequenze \math{X} e \math{Y} rispettivamente di
		lunghezza \math{m} e \math{n}, siano \math{X_{i} = X[1 : i]}
		e \math{Y_{j} = Y[1 : j]} i prefissi di lunghezza \math{i} e
		\math{j} delle rispettive sequenze. La soluzione \math{S_{i, j}}
		per l'\math{i, j}-esima istanza del problema corrisponde a
		trovare la soluzione ottimale per il problema della lunghezza
		della trascrizione rispetto alle sottosequenze \math{X_{i}} e
		\math{Y_{j}}. La soluzione per le intere sequenze \math{X} e
		\math{Y} è la soluzione per l'istanza \math{X_{m}, Y_{n}}.

		\begin{example}
			\begin[width = 35%fw]{parbox}
				\begin[cols = 11%fw 11%fw 11%fw 11%fw 11%fw 11%fw
							  11%fw 11%fw 11%fw, cellborder = 0]{ptable}
					\begin{row}
						\cell{R} \cell{I} \cell{/}
						\cell{D} \cell{/} \cell{D}
						\cell{/} \cell{/} \cell{I}
					\end{row}
					\begin{row}
						\cell{v} \cell{} \cell{i}
						\cell{n} \cell{t} \cell{n}
						\cell{e} \cell{r} \cell{}
					\end{row}
					\begin{row}
						\cell{w} \cell{r} \cell{i}
						\cell{} \cell{t} \cell{}
						\cell{e} \cell{r} \cell{s}
					\end{row}
				\end{ptable}
			\end{parbox}
			\begin[width = 55%fw, padding = 5%fw]{parbox}
				La sequenza \math{X = vintner} può essere trasformata nella
				sequenza \math{Y = writers} mediante 5 operazioni: sostituire
				\math{v} con \math{w}, inserire \math{r}, eliminare \math{n},
				eliminare \math{n} (di nuovo), inserire \math{s}. Le altre 4
				operazioni sono no-op, perché quei caratteri in quelle posizioni
				sono già corretti. Pertanto, si ha che \math{d(X, Y) = 5}.
			\end{parbox}
		\end{example}

	\subsection{Programmazione dinamica: equazione di ricorrenza}

		Il caso base della relazione di ricorrenza è immediato. Il
		numero di operazioni necessarie a trasformare la sequenza
		vuota in sé stessa è zero, perché non c'è alcuna operazione
		da compiere, e di conseguenza il relativo trascritto sarà la
		sequenza vuota. Similmente, per trasformare una sequenza generica
		di lunghezza \math{i} nella sequenza vuota sono necessarie \math{i}
		rimozioni, pertanto la lunghezza della relativa trascrizione è
		\math{i}. Infine, per trasformare la sequenza vuota in una sequenza
		generica di lunghezza \math{j} sono necessarie \math{j} operazioni
		di inserimento, pertanto la lunghezza della relativa trascrizione è
		\math{j}.

		\begin[mode = display]{math}
			S_{i, j} =
			\{\table[columnalign = left left]{
				0 & \mi{se} \thickspace i = 0 \wedge j = 0 \\
				i & \mi{se} \thickspace i > 0 \wedge j = 0 \\
				j & \mi{se} \thickspace i = 0 \wedge j > 0 \\
			}
		\end{math}

		Per quanto riguarda il passo ricorsivo, si assuma di avere a
		disposizione tutte le soluzioni nella forma \math{S_{a, b}},
		con \math{1 \leq a < i} e \math{1 \leq b < j}, e di voler
		calcolare \math{S_{i, j}}. Possono verificarsi solamente due
		situazioni, mutualmente esclusive: l'\math{i}-esimo carattere di
		\math{X_{i}} e uguale al \math{j}-esimo carattere di \math{Y_{j}}
        oppure l'\math{i}-esimo carattere di \math{X_{i}} è diverso dal
        \math{j}-esimo carattere di \math{Y_{j}}.

		Nel primo caso, la \math{i, j}-esima soluzione coincide
		con la \math{i - 1, j - 1}-esima. Questo perché è l'unica
		situazione in cui è possibile non aggiungere alcun carattere
		alla trascrizione, e dato che questa può solo crescere di
		lunghezza o rimanere invariata, non aggiungere alcun carattere
		è la scelta che per definizione ne minimizza la lunghezza.

		Nel secondo caso, la soluzione ottimale per la \math{i, j}-esima
		istanza deve necessariamente essere maggiore di tutte le soluzioni
		per istanze precedenti. Le uniche soluzioni candidate per tale
		istanza sono \math{S_{i - 1, j}}, \math{S_{i - 1, j}} e
		\math{S_{i - 1, j - 1}}, alle quali viene accodato uno dei
		caratteri \math{I}, \math{D} o \math{R}. Dato che sono tutte
		valide, il criterio di scelta consiste nello scegliere la
		soluzione minore.

		\begin[mode = display]{math}
			S_{i, j} =
			\{\table[columnalign = left left]{
				S_{i - 1, j - 1} &
				\mi{se} \thickspace X[i] = Y[j] \\
				1 + \mi{min}\{S_{i - 1, j}, S_{i, j - 1}, S_{i - 1, j - 1}\} &
				\mi{altrimenti} \\
			}
		\end{math}

	\subsection{Programmazione dinamica: implementazione bottom-up}

		L'algoritmo bottom-up viene costruito a partire dall'equazione di
		ricorrenza sfruttando una tabella \math{c}. In ciascuna cella
		\math{c[i, j]} viene riportato il valore della soluzione ottimale
		per la \math{i, j}-esima istanza del problema, che viene utilizzata
		per calcolare i valori ottimali per le istanze successive. L'algoritmo
		riceve in input le due sequenze \math{X} e \math{Y} e restituisce in
		output \math{c[\abs{X}][\abs{Y}]}, la soluzione del problema.

		Si noti come le celle che hanno 0 come uno dei due indici possano
		venire riempite immediatamente con il valore dell'altro indice, come
		da caso base dell'equazione di ricorrenza.

		\begin{verbatim}
			procedure ED(X, Y)
			    for i \unichar{U+2190} 0 to |X| do
			        c[i][0] \unichar{U+2190} i
			    for j \unichar{U+2190} 0 to |Y| do
			        c[0][j] \unichar{U+2190} j

			    \bigskip
			    for i \unichar{U+2190} 1 to |X| do
			        for j \unichar{U+2190} 1 to |Y| do
			            if X[i] = Y[j] then
			                c[i][j] \unichar{U+2190} c[i - 1][j - 1]
			            else
			                c[i][j] \unichar{U+2190} 1 + min\{c[i - 1][j], c[i][j - 1], c[i - 1][j - 1]\}

			    \bigskip
			    return c[|X|][|Y|]
		\end{verbatim}

		È facile notare come il tempo di esecuzione dell'algoritmo
		sia \math{O(nm)}, dove \math{n} e \math{m} sono le lunghezze
		di rispettivamente la stringa \math{X} e la stringa \math{Y}.
		I primi due cicli eseguono una operazione immediata rispettivamente
		per \math{n} e per \math{m} volte, dopodiché si presenta un doppio
		ciclo innestato: il ciclo esterno esegue il ciclo interno \math{m}
		volte, mentre il ciclo interno esegue \math{n} volte un blocco di
		decisione il cui tempo di esecuzione può considerarsi immediato.
		Si ha allora che, asintoticamente, \math{O(m) + O(n) + O(mn) = O(mn)}.

		\begin{example}
			\begin[cols = 10%fw 10%fw 10%fw 10%fw 10%fw 10%fw 10%fw 10%fw]{ptable}
				\begin{row}
					\cell{} \cell{} \cell{\strong{s}} \cell{\strong{u}}
					\cell{\strong{n}} \cell{\strong{d}} \cell{\strong{a}}
					\cell{\strong{y}}
				\end{row}
				\begin{row}
					\cell{} \cell{0} \cell{1} \cell{2}
					\cell{3} \cell{4} \cell{5} \cell{6}
				\end{row}
				\begin{row}
					\cell{\strong{s}} \cell{1} \cell{0} \cell{1}
					\cell{2} \cell{3} \cell{4} \cell{5}
				\end{row}
				\begin{row}
					\cell{\strong{a}} \cell{2} \cell{1} \cell{1}
					\cell{2} \cell{3} \cell{3} \cell{4}
				\end{row}
				\begin{row}
					\cell{\strong{t}} \cell{3} \cell{2} \cell{2}
					\cell{2} \cell{3} \cell{4} \cell{4}
				\end{row}
				\begin{row}
					\cell{\strong{u}} \cell{4} \cell{3} \cell{2}
					\cell{3} \cell{3} \cell{4} \cell{5}
				\end{row}
				\begin{row}
					\cell{\strong{r}} \cell{5} \cell{4} \cell{3}
					\cell{3} \cell{4} \cell{4} \cell{5}
				\end{row}
				\begin{row}
					\cell{\strong{d}} \cell{6} \cell{5} \cell{4}
					\cell{4} \cell{3} \cell{4} \cell{5}
				\end{row}
				\begin{row}
					\cell{\strong{a}} \cell{7} \cell{6} \cell{5}
					\cell{5} \cell{4} \cell{3} \cell{4}
				\end{row}
				\begin{row}
					\cell{\strong{y}} \cell{8} \cell{7} \cell{6}
					\cell{6} \cell{5} \cell{4} \cell{3}
				\end{row}
			\end{ptable}
		\end{example}

	\subsection{Programmazione dinamica: ricostruzione di una soluzione}

		Una volta calcolata la lunghezza della trascrizione ottima, è
		possibile individuarne una ripercorrendo la tabella a ritroso.
		In particolare, questo viene fatto estendendo l'algoritmo per il
		calcolo della lunghezza introducendo una nuova tabella \math{b}
		di puntatori. In particolare, nella cella \math{(i, j)} della
		tabella \math{b} viene inserito:

		\begin{itemize}
			\begin{item}
				Un puntatore \math{\nwarrow} se \math{c(i, j) =
				c(i - 1, j - 1) + 1} o se \math{c(i, j) = c(i - 1, j - 1)}
			\end{item}
			\begin{item}
				un puntatore \math{\leftarrow} se \math{c(i, j) =
				c(i - 1, j) + 1}
			\end{item}
			\begin{item}
				Un puntatore \math{\uparrow} se \math{c(i, j) =
				c(i, j - 1) + 1},
			\end{item}
		\end{itemize}

		\bigskip

		Si noti come vi siano celle in cui potrebbero essere
		inseriti più puntatori, perché più condizioni possono
		verificarsi contemporaneamente. Per convenzione, è
		possibile stabilire un ordine di priorità con cui
		scegliere un puntatore piuttosto che un altro; questo
		porta a diverse possibili ricostruzioni, ma queste
		avranno comunque la stessa lunghezza.

		Per ricavare una trascrizione ottimale a partire dalla tabella, è
		sufficiente seguire un qualsiasi percorso definito dai puntatori
		dalla cella \math{(n, m)} alla cella \math{(0, 0)}. Se ci si sposta
		orizzontalmente, ovvero da una cella \math{(i, j)} ad una cella
		\math{(i, j - 1)}, allora significa che l'operazione più efficiente 
		per quel passaggio è un inserimento. Se ci si sposta verticalmente,
		ovvero da una cella \math{(i, j)} ad una cella \math{(i - 1, j)}
		allora significa che l'operazione più efficiente per quel passaggio
		è una rimozione. Se ci si sposta diagonalmente, ovvero da una cella
		\math{(i, j)} ad una cella \math{(i - 1, j - 1)}, allora significa
		che l'operazione più efficiente per quel passaggio è una
		sostituzione se \math{X[i] \ne Y[j]} o una no-op altrimenti.

		Alla vecchia procedura opportunamente modificata ne viene
		aggiunta un'altra, \tt{PRINT-ED}. Questa ha in input la
		tabella \math{b}, la stringa \math{X}, la stringa \math{Y}
		e due indici di posizione \math{i} e \math{j}, mentre in
		output ha una delle possibili trascrizioni ottimali per
		le stringhe in input. La prima chiamata alla procedura ha
		\math{\abs{X}} come valore per \math{i} e \math{\abs{Y}}
		come valore per \math{j}, in modo da ottenere la soluzione
		per l'istanza \math{\abs{X}, \abs{Y}}. Si noti come la
		trascrizione restituita dalla procedura abbia l'ordine dei
		caratteri invertito, perché questi sono restituiti dall'ultimo
		al primo.

		\begin[width = 62.5%fw]{parbox}
			\begin{verbatim}
				procedure ED(X, Y)
				    for i \unichar{U+2190} 0 to |X| do
				        c[i, 0] \unichar{U+2190} i
				        b[i, j] \unichar{U+2190} "\unichar{U+2190}"
				    for j \unichar{U+2190} 0 to |Y| do
				        c[0, j] \unichar{U+2190} j
				        b[i, j] \unichar{U+2190} "\unichar{U+2191}"

				    \bigskip
				    for i \unichar{U+2190} 1 to |X| do
				        for j \unichar{U+2190} 1 to |Y| do
				            if X[i] = Y[j] then
				                c[i, j] \unichar{U+2190} c[i - 1, j - 1]
				                b[i, j] \unichar{U+2190} "\unichar{U+2196}"
				            else
				                if (c[i - 1, j - 1] \unichar{U+2264} c[i, j - 1]) and
				                   (c[i - 1, j - 1] \unichar{U+2264} c[i - 1, j]) then
				                    c[i, j] \unichar{U+2190} c[i - 1, j - 1] + 1
				                    b[i, j] \unichar{U+2190} "\unichar{U+2196}"
				                else if (c[i - 1, j] \unichar{U+2264} c[i, j - 1]) and
				                        (c[i - 1, j] \unichar{U+2264} c[i - 1, j - 1]) then
				                    c[i, j] \unichar{U+2190} c[i - 1, j] + 1
				                    b[i, j] \unichar{U+2190} "\unichar{U+2190}"
				                else
				                    c[i, j] \unichar{U+2190} c[i, j - 1] + 1
				                    b[i, j] \unichar{U+2190} "\unichar{U+2191}"

				    \bigskip
				    return c, b
			\end{verbatim}
		\end{parbox}
		\begin[width = 37.5%fw]{parbox}
			\begin{verbatim}
				procedure PRINT-ED(X, Y, i, j, b)
				    if i = 0 or j = 0 then
				        return

				    \bigskip
				    if b[i, j] = "\unichar{U+2190}" then
				        print "I"
				        PRINT-ED(X, Y, i - 1, j, b)
				    else if b[i, j] = "\unichar{U+2191}" then
				        print "D"
				        PRINT-ED(X, Y, i, j - 1, b)
				    else
				        if X[i] \unichar{U+2260} Y[j] then
				            print "R"
				        PRINT-ED(X, Y, i - 1, j - 1, b)
			\end{verbatim}
		\end{parbox}
		\par

		Sebbene la procedura sia ricorsiva, il suo tempo di esecuzione è 
		comunque proporzionale alle dimensioni della tabella \math{b},
		perché la ricorsione è una tail-recursion.

		\begin{example}
			\begin[width = 50%fw]{parbox}
				\begin[cols = 10%fw 10%fw 10%fw 10%fw 10%fw 10%fw 10%fw 10%fw 10%fw]{ptable}
					\begin{row}
						\cell{} \cell{} \cell{\strong{w}} \cell{\strong{r}}
						\cell{\strong{i}} \cell{\strong{t}} \cell{\strong{e}}
						\cell{\strong{r}} \cell{\strong{s}}
					\end{row}
					\begin{row}
						\cell{ }
						\cell{0} \cell{1} \cell{2} \cell{3}
						\cell{4} \cell{5} \cell{6} \cell{7}
					\end{row}
					\begin{row}
						\cell{\strong{v}}
						\cell{1} \cell{1} \cell{2} \cell{3}
						\cell{4} \cell{5} \cell{6} \cell{7}
					\end{row}
					\begin{row}
						\cell{\strong{i}}
						\cell{2} \cell{2} \cell{2} \cell{2}
						\cell{3} \cell{4} \cell{5} \cell{6}
					\end{row}
					\begin{row}
						\cell{\strong{n}}
						\cell{3} \cell{3} \cell{3} \cell{3}
						\cell{3} \cell{4} \cell{5} \cell{6}
					\end{row}
					\begin{row}
						\cell{\strong{t}}
						\cell{4} \cell{4} \cell{4} \cell{4}
						\cell{3} \cell{4} \cell{5} \cell{6}
					\end{row}
					\begin{row}
						\cell{\strong{n}}
						\cell{5} \cell{5} \cell{5} \cell{5}
						\cell{4} \cell{4} \cell{5} \cell{6}
					\end{row}
					\begin{row}
						\cell{\strong{e}}
						\cell{6} \cell{6} \cell{6} \cell{6}
						\cell{5} \cell{4} \cell{5} \cell{6}
					\end{row}
					\begin{row}
						\cell{\strong{r}}
						\cell{7} \cell{7} \cell{6} \cell{7}
						\cell{6} \cell{5} \cell{4} \cell{5}
					\end{row}
				\end{ptable}
			\end{parbox}
			\begin[width = 50%fw]{parbox}
				\begin[cols = 10%fw 10%fw 10%fw 10%fw 10%fw 10%fw 10%fw 10%fw 10%fw]{ptable}
					\begin{row}
						\cell{} \cell{} \cell{\strong{w}} \cell{\strong{r}}
						\cell{\strong{i}} \cell{\strong{t}} \cell{\strong{e}}
						\cell{\strong{r}} \cell{\strong{s}}
					\end{row}
					\begin{row}
						\cell{}
						\cell{}
						\cell{\math{\leftarrow}}
						\cell{\math{\leftarrow}}
						\cell{\math{\leftarrow}}
						\cell{\math{\leftarrow}}
						\cell{\math{\leftarrow}}
						\cell{\math{\leftarrow}}
						\cell{\math{\leftarrow}}
					\end{row}
					\begin{row}
						\cell{\strong{v}}
						\cell{\math{\uparrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
					\end{row}
					\begin{row}
						\cell{\strong{i}}
						\cell{\math{\uparrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\leftarrow}}
						\cell{\math{\leftarrow}}
						\cell{\math{\leftarrow}}
						\cell{\math{\leftarrow}}
					\end{row}
					\begin{row}
						\cell{\strong{n}}
						\cell{\math{\uparrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\uparrow}}
						\cell{\math{\leftarrow}}
						\cell{\math{\leftarrow}}
						\cell{\math{\leftarrow}}
					\end{row}
					\begin{row}
						\cell{\strong{t}}
						\cell{\math{\uparrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
					\end{row}
					\begin{row}
						\cell{\strong{n}}
						\cell{\math{\uparrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\uparrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
					\end{row}
					\begin{row}
						\cell{\strong{e}}
						\cell{\math{\uparrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\uparrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
					\end{row}
					\begin{row}
						\cell{\strong{r}}
						\cell{\math{\uparrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\uparrow}}
						\cell{\math{\uparrow}}
						\cell{\math{\nwarrow}}
						\cell{\math{\leftarrow}}
					\end{row}
				\end{ptable}
			\end{parbox}
		\end{example}

\end{sile}
