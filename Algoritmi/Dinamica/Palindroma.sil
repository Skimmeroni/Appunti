\begin{sile}

    \subsection{Definizione del problema}

        Una stringa \math{X = \{x_{1}, x_{2}, \unicodeellipsis, x_{n}\}}
        é detta \strong{palindroma} se é uguale alla stringa \math{X' =
        \{x_{n}, \unicodeellipsis, x_{2}, x_{1}\}}, che é composta dagli
        stessi caratteri di \math{X} ma in ordine inverso. Il \strong{problema
        della chiusura palindroma} chiede di trovare, per una generica stringa
        \math{X}, il numero minimo di caratteri da inserirvi per renderla
        palindroma.

    \subsection{Programmazione dinamica: equazione di ricorrenza}

        Data una stringa \math{X} di lunghezza \math{n}, sia \math{X_{i, j}
        = X[i : j]} la sottostringa di \math{X} che ha il primo carattere in
        posizione \math{i} e l'ultimo carattere in posizione \math{j}. La
        soluzione \math{S_{i, j}} per l'\math{i, j}-esima istanza del problema
        corrisponde a trovare la soluzione ottimale per il problema della
        chiusura palindroma rispetto alla sottostringa \math{X_{i, j}}. La
        soluzione per l'intera stringa \math{X} é la soluzione per l'istanza
        \math{X_{1, n}}.

        Il caso base é immediato. Se la sottostringa \math{X_{i, j}} é
        la stringa vuota, ovvero se \math{i > j}, non vi é bisogno di
        aggiungere alcun carattere a \math{X_{i, j}} per renderla
        palindroma, perché la stringa vuota é per definizione palindroma.
        Similmente, se la sottostringa é formata da un solo carattere,
        ovvero se \math{i = j}, non vi é bisogno di aggiungere alcun
        carattere a \math{X_{i, j}} per renderla palindroma, perché una
        stringa di lunghezza unitaria é per definizione palindroma.

        \begin[mode = display]{math}
            S_{i, j} = 0 \thickspace \mi{se} \thickspace i \geq j
        \end{math}

        Per quanto riguarda il passo ricorsivo, si assuma di avere
		a disposizione tutte le soluzioni nella forma \math{S_{a,
		b}}, con \math{1 \leq a < i} e \math{1 \leq b < j}, e di
		voler calcolare \math{S_{i, j}}. Possono verificarsi solamente
		due situazioni: il primo ed ultimo carattere di \math{X_{i, j}}
		sono uguali oppure sono diversi.

        Se sono uguali, allora tale stringa é palindroma solo se lo é
        anche la sottostringa ottenuta eliminandovi tali caratteri,
        ovvero se lo é anche \math{X_{i + 1, j - 1}}. Se invece sono
        distinti, allora tale stringa é palindroma solo se lo é anche
        la sottostringa ottenuta eliminandovi il primo oppure l'ultimo
        carattere.        

        \begin[mode = display]{math}
            S_{i, j} =
            \{\table[columnalign = left left]{
                S_{i + 1, j - 1} & \mi{se} \thickspace x_{i} = x_{j} \\
                1 + \mi{min}\{S_{i + 1, j}, S_{i, j - 1}\} & \mi{se} \thickspace x_{i} \ne x_{j} \\
            }
        \end{math}

    \subsection{Programmazione dinamica: implementazione bottom-up}

        L'algoritmo bottom-up viene costruito a partire dall'equazione
        di ricorrenza sfruttando una tabella \math{c}. In ciascuna cella
		\math{c[i, j]} viene riportato il valore della soluzione ottimale
		per la \math{i, j}-esima istanza del problema, che viene utilizzata
		per calcolare i valori ottimali per le istanze successive.
		L'algoritmo riceve in input la stringa \math{X} e restituisce
		in output \math{c[1, |X|]}, la cella che contiene la soluzione del
		problema.

        \begin{verbatim}
            procedure PAL-CLOSURE(X)
                for i = 0 to |X| do
                    for j = 0 to |X| do
                        c[i, j] = 0

                \bigskip
                for i = |X| down to 1 do
                    for j = 1 to |X| do
                        if (i < j) then
                            if (X[i] == X[j]) then
                                c[i, j] = c[i + 1, j - 1]
                            else
                                c[i, j] = 1 + min(c[i + 1, j], c[i, j - 1])

                \bigskip
                return c[1, |X|]
        \end{verbatim}

\end{sile}
