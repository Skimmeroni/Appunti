\begin{sile}

    \subsection{Definizione del problema}

        Sia \math{V = (v_{1}, v_{2}, \unicodeellipsis, v_{n})} un vettore 
        composto da numeri interi (positivi e/o negativi). Il peso di un
        vettore è definito come la somma dei suoi elementi; per convenzione,
        il peso del vettore nullo si assume essere zero.

        \begin[mode = display]{math}
            V{(A)} =
            \{\table[columnalign = left]{
                \sum_{i = 1}^{|A|} v_{i} & \mi{se} \thickspace A \ne \varnothing \\
                0 & \mi{se} \thickspace A = \varnothing \\
            }
        \end{math}

        Si dice \strong{sottovettore} di \math{V} un qualunque vettore \math{V' =
        (v_{h}, v_{h + 1}, \unicodeellipsis, v_{k})} con \math{1 \leq h \leq k
        \leq n}. Sia \math{\mi{SV}(V)} l'insieme che contiene tutti i sottovettori
        costruibili a partire da \math{V}.

        \begin[mode = display]{math}
            \mi{SV}(V) = \{(v_{h}, v_{h + 1}, \unicodeellipsis, v_{k}) |
                            1 \leq h \leq k \leq n\}
        \end{math}

        Il \strong{problema del sottovettore di peso massimo}
        (\strong{HSV}) richiede di trovare, per un vettore \math{V},
        il sottovettore \math{V*} che, fra tutti i sottovettori di
        \math{\mi{SV}(V)}, è quello avente peso complessivo massimo.

        \begin{example}
            Dato il vettore \math{V = (3, -5, 10, 2, -3, 1, 4, -8, 7, -6, 1)},
            il sottovettore di peso massimo è \math{V* = (10, 2, -3, 1, 4)},
            avente peso 14.
        \end{example}

        Anziché affrontare il problema direttamente, si preferisce prima
		trovare il peso complessivo di un possibile sottovettore di peso
		massimo di un vettore e poi, sulla base di questa informazione,
		ricostruire il sottovettore "a ritroso". Pertanto, il problema
		effettivamente in esame sará il problema del peso complessivo del
		sottovettore di peso massimo.

        Attaccare il problema HSV direttamente tramite programmazione
        dinamica è complesso. Un miglior approccio consiste nel restringere
        i requisiti del problema per considerarne una versione semplificata.

        Una versione più semplice del problema HSV, chiamato \strong{HSV
        vincolato}, richiede di trovare, fra tutti i sottovettori costruibili
        a partire da un vettore \math{V}, quello avente peso complessivo
        massimo e avente l'ultimo elemento coincidente con l'ultimo elemento
        del vettore originario.

        Dato un vettore \math{V} avente cardinalità \math{n},
        sia \math{V_{i}} il sottovettore \math{(v_{1}, v_{2},
        \unicodeellipsis, v_{i})}. La soluzione \math{S_{i}}
        per l'\math{i}-esima istanza del problema corrisponde
        a trovare la soluzione ottimale per il problema HSV
        vincolato rispetto al sottovettore \math{V_{i}}. La
        soluzione per l'intero vettore \math{V} è la soluzione
        per l'istanza \math{V_{n}}.

    \subsection{Programmazione dinamica: equazione di ricorrenza}

        Il caso base dell'equazione di ricorrenza è immediato: se
        il vettore è il vettore nullo, allora il sottovettore di
        peso massimo più lungo vincolato è esso stesso il vettore
        nullo. D'altro canto, se il vettore è composto da un solo
        elemento, tale elemento deve essere parte per definizione
        della soluzione ottima per tale istanza del problema, ed è
        inoltre l'unico elemento di tale soluzione.

        \begin[width = 50%fw]{parbox}
            \begin[mode = display]{math}
				S_{0} = \epsilon
            \end{math}
        \end{parbox}
        \begin[width = 50%fw]{parbox}
            \begin[mode = display]{math}
				S_{1} = v_{1}
            \end{math}
        \end{parbox}
        \par

        Per quanto riguarda il passo ricorsivo, si assuma di avere a
        disposizione tutte le soluzioni \math{S_{i - 1}, S_{i - 2},
        \unicodeellipsis} e di voler calcolare \math{S_{i}}. Dato che
        il problema HSV vincolato richiede di trovare il peso complessivo
        del sottovettore di peso massimo che termini con l'ultimo elemento
        del vettore, il peso dell'\math{i}-esimo elemento del vettore sará
        certamente parte della soluzione.

        L'unica scelta da compiere in merito a tale soluzione è se sommarvi
        o non sommarvi anche la \math{i - 1}-esima soluzione ottimale. Se
        tale soluzione é un valore negativo, allora sommando \math{S_{i - 1}}
        a \math{v_{i}} si otterrebbe un valore inferiore al solo \math{v_{i}},
        e quindi una soluzione peggiore di \math{v_{i}}. Se tale soluzione
        é invece un valore positivo, allora sommando \math{S_{i - 1}} a
        \math{v_{i}} si ottiene un valore maggiore del solo \math{v_{i}},
        e quindi una soluzione migliore di \math{v_{i}}. Se tale soluzione
        ha valore nullo, allora sommandola o non sommandola a \math{v_{i}}
        si ottiene lo stesso risultato, pertanto questo caso puó essere
        accorpato indifferentemente ad uno dei precedenti.

		\begin[mode = display]{math}
			S_{i} =
			\{\table[columnalign = left]{
				v_{i} & \mi{se} \thickspace S_{i - 1} \leq 0 \\
				S_{i - 1} + v_{i} & \mi{se} \thickspace S_{i - 1} > 0 \\
			}
		\end{math}

      \subsection{Programmazione dinamica: implementazione bottom-up}

        L'algoritmo bottom-up viene costruito a partire dall'equazione
        di ricorrenza sfruttando un vettore \math{c}. In ciascuna cella
		\math{c[i]} viene riportato il valore della soluzione ottimale
		per la \math{i}-esima istanza del problema, che viene utilizzata
		per calcolare i valori ottimali per le istanze successive.
		L'algoritmo riceve in input il vettore \math{V} e restituisce
		in output il vettore \math{c}.

		\begin{verbatim}
			procedure HSV(V)
			    c[0] \unichar{U+2190} 0
			    c[1] \unichar{U+2190} V[1]

			    \bigskip
			    for i \unichar{U+2190} 2 to |V| do
			        if (c[i - 1] \unichar{U+2264} 0) then
			            c[i] \unichar{U+2190} V[i]
			        else
			            c[i] \unichar{U+2190} c[i - 1] + V[i]

			    \bigskip
			    return c
		\end{verbatim}

        È facile notare come il tempo di esecuzione dell'algoritmo sia
        \math{O(n)}, dove \math{n} è la lunghezza del vettore \math{V}.
        Questo perché tale algoritmo è composto da un solo ciclo che
        esegue per \math{n} volte una istruzione con tempo di esecuzione
        immediato.

    \subsection{Osservazioni}

        Il problema HSV non vincolato può essere ridotto al problema HSV
        vincolato. Infatti, la soluzione del problema HSV non vincolato non
        è altro che la maggior soluzione parziale del problema HSV vincolato.

\end{sile}
